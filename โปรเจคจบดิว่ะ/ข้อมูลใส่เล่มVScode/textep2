
บทที่ 2
ทฤษฎีและเนื้อหาที่เกี่ยวข้อง

2.1 บทนำ
	ในการพัฒนาระบบ [Smart Information Chatbot System of Engineering] คณะผู้จัดทำได้ศึกษาค้นคว้าหลักการ ทฤษฎี และเทคโนโลยีที่เกี่ยวข้อง เพื่อนำมาประยุกต์ใช้ในการออกแบบและพัฒนาระบบให้มีประสิทธิภาพ สามารถตอบสนองความต้องการของผู้ใช้งานได้อย่างถูกต้องแม่นยำ โดยเนื้อหาในบทนี้จะครอบคลุมองค์ความรู้ตั้งแต่พื้นฐานกระบวนการทำงานของ แชทบอท, การประมวลผลภาษาธรรมชาติ (NLP) เพื่อให้ระบบเข้าใจภาษาไทย, เทคนิคการสืบค้นและจัดเก็บข้อมูลอย่างเป็นระบบ, สถาปัตยกรรมของเว็บแอปพลิเคชันและการเชื่อมต่อผ่าน API, ตลอดจนหลักการออกแบบส่วนติดต่อผู้ใช้ (UI/UX) เพื่อสร้างประสบการณ์การใช้งานที่ดี ซึ่งมีรายละเอียดดังต่อไปนี้

2.2. ทฤษฎีเกี่ยวกับระบบแชทบอท (Chatbot System)
	2.2.1 ประเภทของแชทบอท: อธิบายความแตกต่างระหว่าง Rule-based (ทำงานตามกฎ), AI-powered (ใช้ Machine Learning) และ Hybrid (ลูกผสม) ซึ่งโปรเจคนี้อาจจะเน้นแบบ Hybrid หรือ Rule-based ที่มีความซับซ้อน
		2.2.1.1 Rule-based Chatbot (แชทบอทแบบอิงกฎ) แชทบอทประเภทนี้ทำงานโดยอาศัยชุดคำสั่งหรือกฎเกณฑ์ที่ถูกกำหนดไว้อย่างตายตัว (Predefined Rules) ภายใต้โครงสร้างแบบผังต้นไม้การตัดสินใจ (Decision Tree) ระบบจะทำหน้าที่โต้ตอบกับผู้ใช้งานตามเส้นทางที่ถูกออกแบบไว้ล่วงหน้าเท่านั้น
		2.2.1.2 AI-powered Chatbot (แชทบอทปัญญาประดิษฐ์) หรือเรียกว่า Conversational AI คือแชทบอทที่ขับเคลื่อนด้วยเทคโนโลยีปัญญาประดิษฐ์ โดยอาศัยการประมวลผลภาษาธรรมชาติ (Natural Language Processing: NLP) และการเรียนรู้ของเครื่อง (Machine Learning) เพื่อทำความเข้าใจเจตนา (Intent) ของผู้ใช้งาน
		2.2.1.3 Hybrid Chatbot (แชทบอทแบบลูกผสม) คือการบูรณาการเทคโนโลยีระหว่างแชทบอทแบบอิงกฎ (Rule-based) และแชทบอทปัญญาประดิษฐ์ (AI-powered) เข้าด้วยกัน เพื่อดึงจุดเด่นของทั้งสองระบบมาใช้ในการเพิ่มประสิทธิภาพการให้บริการสูงสุด
	2.2.2 องค์ประกอบหลัก (Architecture)
	โครงสร้างการทำงานของแชทบอทโดยทั่วไปประกอบด้วย 4 ส่วนสำคัญที่ทำงานประสานกัน เพื่อแปลงข้อมูลนำเข้า (Input) จากมนุษย์ ให้เป็นการตอบสนอง (Response) ที่เหมาะสม ดังนี้
		2.2.2.1 ส่วนติดต่อผู้ใช้ (User Interface - UI) ส่วนติดต่อผู้ใช้ หรือ UI คือช่องทาง (Channel) ที่ทำหน้าที่เป็นสื่อกลางในการรับส่งข้อมูลระหว่างผู้ใช้งานกับระบบคอมพิวเตอร์ ทำหน้าที่รับข้อมูลนำเข้า (Input) ซึ่งอาจอยู่ในรูปแบบข้อความ (Text) หรือเสียง (Voice) และแสดงผลลัพธ์ (Output) กลับไปยังผู้ใช้
		1. ทฤษฎีที่เกี่ยวข้อง: หลักการปฏิสัมพันธ์ระหว่างมนุษย์และคอมพิวเตอร์ (Human-Computer Interaction: HCI) และการออกแบบประสบการณ์ผู้ใช้ (User Experience: UX)
		2. รูปแบบการทำงาน: ในปัจจุบัน UI มักจะเชื่อมต่อผ่าน Platform ต่างๆ เช่น Web Widget, Mobile Application หรือ Social Media Platform (Line, Facebook Messenger) ผ่านทาง API (Application Programming Interface)
		2.2.2.2 ส่วนประมวลผลภาษาธรรมชาติ (NLP Engine) NLP (Natural Language Processing) คือกลไกหลักที่เปรียบเสมือนสมองของแชทบอท ทำหน้าที่วิเคราะห์และทำความเข้าใจภาษามนุษย์ที่ไม่มีรูปแบบตายตัว (Unstructured Data) ให้เป็นข้อมูลที่คอมพิวเตอร์สามารถนำไปประมวลผลต่อได้ โดยแบ่งกระบวนการย่อยเป็น
		1. Natural Language Understanding (NLU): การทำความเข้าใจภาษา ประกอบด้วย
		- Intent Classification: การจำแนกเจตนาของผู้ใช้ว่าต้องการสื่อสารเรื่องอะไร
		- Entity Extraction: การสกัดคำสำคัญหรือข้อมูลจำเพาะจากประโยค เช่น วันที่, สถานที่,    ชื่อสินค้า
		2. Natural Language Generation (NLG): การสร้างประโยคตอบกลับให้เป็นภาษาธรรมชาติที่มนุษย์เข้าใจได้
		2.2.2.3 ส่วนจัดการบทสนทนาและสถานะ (Dialog Manager) Dialog Manager (DM) ทำหน้าที่เป็นหน่วยควบคุมตรรกะ (Logic) ของการสนทนา เพื่อกำหนดว่าระบบควรจะตอบโต้ผู้ใช้งานอย่างไร โดยอาศัยข้อมูลที่ได้จาก NLP
		1. หน้าที่หลัก
		- State Tracking: การติดตามสถานะของการสนทนาว่าปัจจุบันคุยถึงขั้นตอนใด
		- Context Management: การจดจำบริบทและข้อมูลก่อนหน้า (History) เพื่อให้การสนทนาต่อเนื่อง
		2. ประเภทของระบบ: อาจใช้ระบบแบบกฎเกณฑ์ (Rule-based) สำหรับคำถามง่ายๆ หรือใช้ระบบ Machine Learning สำหรับบทสนทนาที่มีความซับซ้อน (Contextual Conversation)
		2.2.2.4 คลังความรู้และฐานข้อมูล (Knowledge Base/Database) ส่วนจัดเก็บข้อมูลสารสนเทศที่แชทบอทต้องนำมาใช้ในการประมวลผลหรือตอบคำถาม แบ่งเป็น 2 ลักษณะ คือ
		1. Knowledge Base (KB): คลังความรู้ที่มักเก็บข้อมูลแบบไม่มีโครงสร้าง หรือกึ่งโครงสร้าง เช่น ไฟล์เอกสาร, คู่มือการใช้งาน, หรือชุดคำถาม-คำตอบ (FAQ) ที่เตรียมไว้
		2. Database: ฐานข้อมูลที่มีโครงสร้างชัดเจน (Structured Data) ใช้เก็บข้อมูลธุรกรรม (Transaction) เช่น ข้อมูลสมาชิก, ประวัติการสั่งซื้อ หรือสต็อกสินค้า เพื่อให้ Dialog Manager ดึงไปใช้งานแบบ Real-time
	2.2.3 ประโยชน์ของระบบแชทบอทต่อองค์กร การนำเทคโนโลยีแชทบอทมาประยุกต์ใช้ในกระบวนการทางธุรกิจ ก่อให้เกิดประโยชน์ต่อองค์กรในหลายมิติ ทั้งด้านการบริหารจัดการต้นทุน การยกระดับการให้บริการ และการวางแผนกลยุทธ์ โดยสามารถจำแนกประเด็นสำคัญได้ดังนี้
		2.2.3.1 การลดต้นทุนและการใช้ทรัพยากรบุคคล (Cost and Resource Optimization)       แชทบอทช่วยลดภาระค่าใช้จ่ายในการจ้างพนักงานสำหรับตอบคำถามพื้นฐานซ้ำๆ (Routine Inquiries) ทำให้องค์กรสามารถบริหารจัดการทรัพยากรบุคคลให้ไปโฟกัสกับงานที่มีความซับซ้อนหรืองานเชิงวิเคราะห์ที่ต้องใช้ทักษะมนุษย์ได้มากขึ้น ส่งผลให้ต้นทุนต่อหน่วยในการให้บริการลูกค้า (Cost per Contact) ลดลงในระยะยาว
		2.2.3.2 การให้บริการที่ต่อเนื่องตลอด 24 ชั่วโมง (24/7 Availability) ข้อจำกัดเรื่องเวลาทำงานของมนุษย์ไม่ส่งผลกระทบต่อแชทบอท ทำให้องค์กรสามารถให้บริการลูกค้าได้ตลอด 24 ชั่วโมง โดยไม่มีวันหยุด ซึ่งเป็นปัจจัยสำคัญในการสร้างความพึงพอใจและตอบโจทย์พฤติกรรมผู้บริโภคในยุคดิจิทัลที่ต้องการความช่วยเหลือแบบทันท่วงที (Real-time)
		2.2.3.3 การรองรับผู้ใช้งานจำนวนมากพร้อมกัน (High Scalability) ระบบแชทบอทสามารถรองรับการสนทนากับผู้ใช้งานจำนวนมากได้ในเวลาเดียวกัน (Concurrent Users) โดยไม่ส่งผลกระทบต่อความเร็วในการตอบกลับ แตกต่างจากพนักงาน (Human Agent) ที่สามารถดูแลลูกค้าได้ทีละ 1-2 รายเท่านั้น ช่วยแก้ปัญหาคอขวดในช่วงเวลาที่มีปริมาณการติดต่อสูง (Peak Hours)
		2.2.3.4 ความรวดเร็วและความถูกต้องของข้อมูล (Speed and Accuracy) แชทบอทสามารถสืบค้นข้อมูลจากฐานข้อมูลและตอบกลับได้ในเวลาเสี้ยววินาที ช่วยลดระยะเวลาการรอคอย (Wait Time) ของลูกค้า นอกจากนี้ ข้อมูลที่ตอบกลับยังมีความถูกต้องและเป็นมาตรฐานเดียวกัน (Standardization) ตามที่โปรแกรมไว้ ช่วยลดความผิดพลาดที่เกิดจากมนุษย์ (Human Error)
		2.2.3.5 การเก็บรวบรวมและวิเคราะห์ข้อมูลลูกค้า (Data Collection and Analytics) การสนทนาผ่านแชทบอทเป็นแหล่งข้อมูล Big Data ที่สำคัญ องค์กรสามารถนำประวัติการสนทนา (Chat Logs) ไปวิเคราะห์เพื่อทำความเข้าใจพฤติกรรม ความสนใจ และปัญหาของลูกค้า (Pain Points) นำไปสู่การปรับปรุงสินค้า บริการ หรือการทำแคมเปญการตลาดแบบเฉพาะเจาะจง (Personalization) ได้อย่างแม่นยำ
		2.2.3.6 การสร้างภาพลักษณ์ที่ทันสมัย (Modern Brand Image) การนำเทคโนโลยีปัญญาประดิษฐ์มาใช้ในการบริการลูกค้า ช่วยส่งเสริมภาพลักษณ์ขององค์กรให้ดูทันสมัย มีนวัตกรรม และแสดงถึงความใส่ใจในการพัฒนาช่องทางการสื่อสารเพื่ออำนวยความสะดวกให้แก่ผู้ใช้บริการ

2.3 ทฤษฎีเกี่ยวกับการเรียนรู้ของแชทบอท (Machine Learning for Chatbot)
	2.3.1 ทฤษฎีการเรียนรู้ของแชทบอท (Chatbot Learning Theories) การที่แชทบอทสามารถเข้าใจและตอบโต้ภาษามนุษย์ได้นั้น อาศัยทฤษฎีและกระบวนการเรียนรู้ของเครื่อง (Machine Learning) ซึ่งเป็นการทำให้คอมพิวเตอร์เรียนรู้จากข้อมูล (Data-driven) โดยมีทฤษฎีและโมเดลที่เกี่ยวข้องหลักๆ
		2.3.1.1 การเรียนรู้แบบมีผู้สอน (Supervised Learning) เป็นทฤษฎีพื้นฐานที่สุดที่ใช้ในการสร้างแชทบอทประเภท NLU (Natural Language Understanding)
		1. หลักการ: การป้อนข้อมูลเข้าไปในระบบประกอบด้วย "ข้อมูลนำเข้า" (Input) และ "คำตอบที่ถูกต้อง" (Label/Target) เพื่อให้โมเดลเรียนรู้ความสัมพันธ์
		2. การประยุกต์ใช้ในแชทบอท
		- Intent Classification: สอนให้บอทจำแนกเจตนา เช่น ป้อนประโยค "อยากกินข้าว" พร้อมติดป้ายกำกับว่าเป็น Intent "สั่งอาหาร" เมื่อมีข้อมูลมากพอ บอทจะแยกแยะประโยคใหม่ๆ
		- Entity Recognition: การสอนให้บอทระบุคำเฉพาะ เช่น ชื่อคน สถานที่ หรือเวลาจากประโยคตัวอย่าง
		2.3.1.2 การเรียนรู้เชิงลึก (Deep Learning) และโครงข่ายประสาทเทียม สำหรับการประมวลผลภาษาที่ซับซ้อน ปัจจุบันนิยมใช้โครงข่ายประสาทเทียม (Neural Networks) ที่จำลองการทำงานของสมองมนุษย์
		- Recurrent Neural Networks (RNN) และ LSTM (Long Short-Term Memory): เป็นโมเดลยุคแรกๆ ที่ออกแบบมาเพื่อจัดการข้อมูลแบบลำดับ (Sequence Data) เช่น ประโยคสนทนา โดยมีความสามารถในการ "จดจำ" คำก่อนหน้าเพื่อทำความเข้าใจบริบทของคำถัดไป
		- Transformer Architecture: (ทฤษฎีเบื้องหลัง ChatGPT/Gemini) เป็นสถาปัตยกรรมใหม่ที่ใช้กลไก Self-Attention ช่วยให้โมเดลสามารถเชื่อมโยงความสัมพันธ์ของคำทุกคำในประโยคได้	พร้อมกัน ไม่ว่าจะอยู่ห่างกันแค่ไหน ทำให้เข้าใจบริบทได้ลึกซึ้งกว่า RNN

		2.3.1.3 การเรียนรู้แบบถ่ายโอน (Transfer Learning) ทฤษฎีนี้ช่วยลดข้อจำกัดเรื่องข้อมูลสอน (Training Data) ที่มีจำนวนน้อย
		- หลักการ: การนำโมเดลภาษาขนาดใหญ่ (Pre-trained Language Models) ที่ผ่านการเรียนรู้จากข้อมูลมหาศาลในอินเทอร์เน็ตมาแล้ว (เช่น BERT, GPT) มาทำการปรับจูน (Fine-tuning) ด้วยข้อมูลเฉพาะทางขององค์กร
		- ประโยชน์: ช่วยให้สร้างแชทบอทที่ฉลาดได้เร็วขึ้น โดยไม่ต้องเริ่มสอนภาษาตั้งแต่ศูนย์
		2.3.1.4 การเรียนรู้แบบเสริมกำลัง (Reinforcement Learning) มักใช้ในขั้นตอนการปรับปรุงความลื่นไหลของการสนทนา หรือในแชทบอทขั้นสูง (Generative AI)
		- หลักการ: การเรียนรู้จากการลองผิดลองถูก (Trial and Error) โดยระบบจะได้รับ "รางวัล" (Reward) เมื่อตอบถูกหรือทำให้บทสนทนาดำเนินไปได้ด้วยดี และได้รับ "บทลงโทษ" (Penalty) เมื่อตอบผิด
		- RLHF (Reinforcement Learning from Human Feedback): การให้มนุษย์เข้ามาช่วยให้คะแนนคำตอบของบอท เพื่อจูนให้บอทตอบได้ตรงใจและเป็นธรรมชาติที่สุด
		2.3.1.5 การวัดผลโมเดลการเรียนรู้ (Model Evaluation) ในเชิงทฤษฎี การเรียนรู้ต้องมีการวัดผลเพื่อยืนยันประสิทธิภาพ ค่าทางสถิติที่นิยมใช้ได้แก่
		- Confusion Matrix: ตารางแสดงความถูกต้องและความผิดพลาดในการทำนาย
		- Accuracy: ความแม่นยำโดยรวม
		- F1-Score: ค่าเฉลี่ย Harmonic ระหว่าง Precision และ Recall ซึ่งใช้วัดประสิทธิภาพได้ดีที่สุดในกรณีที่ข้อมูลแต่ละคลาสไม่เท่ากัน
	
2.4 การประมวลผลภาษาธรรมชาติ (Natural Language Processing - NLP)
	การประมวลผลภาษาธรรมชาติ หรือ NLP เป็นสาขาหนึ่งของปัญญาประดิษฐ์ (Artificial Intelligence) ที่มุ่งเน้นให้คอมพิวเตอร์สามารถเข้าใจ ตีความ และตอบสนองต่อภาษามนุษย์ได้ สำหรับระบบแชทบอท กระบวนการ NLP ถือเป็นหัวใจสำคัญในการเปลี่ยนข้อความดิบ (Raw Text) ให้เป็นข้อมูลที่มีความหมาย เพื่อนำไปสู่การประมวลผลคำตอบที่ถูกต้อง โดยมีกระบวนการย่อยดังนี้
	2.4.1 Text Preprocessing การเตรียมข้อมูลข้อความ (Text Preprocessing) คือกระบวนการเตรียมข้อมูลดิบให้พร้อมสำหรับการวิเคราะห์ โดยการลดความซับซ้อนและกำจัดข้อมูลขยะ (Noise) เพื่อให้ระบบสามารถประมวลผลได้อย่างมีประสิทธิภาพสูงสุด
		2.4.1.1 Tokenization: การตัดคำ Tokenization คือกระบวนการแบ่งข้อความหรือประโยคยาวๆ ออกเป็นหน่วยคำย่อยที่เล็กที่สุดที่ยังมีความหมาย เรียกว่า "Token" สำหรับภาษาที่มีการเว้นวรรคคำชัดเจนอย่างภาษาอังกฤษ (Word Segmentation) จะใช้ช่องว่างเป็นตัวกำหนด แต่สำหรับ ภาษาไทย ซึ่งเป็นภาษาที่เขียนติดกัน (Script Continua) กระบวนการนี้จึงมีความซับซ้อนกว่า จำเป็นต้องใช้อัลกอริทึมที่อ้างอิงพจนานุกรม (Dictionary-based) หรือใช้ Machine Learning ในการวิเคราะห์ขอบเขตของคำ เพื่อให้แยกคำได้อย่างถูกต้อง เช่น แปลงประโยค "ตารางเรียนวันนี้" ให้กลายเป็น ["ตาราง", "เรียน", "วัน", "นี้"]
		2.4.1.2 Normalization: การทำความสะอาดข้อความ Normalization คือกระบวนการแปลงข้อความให้อยู่ในรูปแบบมาตรฐานเดียวกัน เพื่อลดความผันแปรของข้อมูล (Data Variance) ซึ่งประกอบด้วย
		- การกำจัดอักขระพิเศษ (Special Character Removal): การลบสัญลักษณ์ที่ไม่สื่อความหมาย เช่น Emoji เครื่องหมายวรรคตอนที่ไม่จำเป็น หรือโค้ด HTML
		- การจัดการคำย่อและคำสแลง: การแปลงภาษาพูดหรือคำย่อให้เป็นคำเต็มที่ระบบเข้าใจ เช่น แปลง "พน." เป็น "พรุ่งนี้" หรือ "มหาลัย" เป็น "มหาวิทยาลัย"
		- Stop Word Removal: การตัดคำฟุ่มเฟือยที่พบบ่อยแต่ไม่มีนัยสำคัญต่อความหมายหลัก เช่น "ครับ" "ค่ะ" "ที่" "ซึ่ง" "อัน" ออกไปเพื่อลดขนาดข้อมูลและเพิ่มประสิทธิภาพการประมวลผล
	2.4.2 Matching Algorithms หลังจากผ่านกระบวนการเตรียมข้อมูล ระบบจะใช้อัลกอริทึมในการจับคู่ข้อความที่ได้รับ (Input) เข้ากับฐานข้อมูลความรู้ (Knowledge Base) หรือเจตนา (Intent) ที่กำหนดไว้ โดยมีเทคนิคสำคัญดังนี้
		2.4.2.1 Keyword Matching: การจับคู่คำหลักแบบตรงตัว เป็นเทคนิคพื้นฐานที่สุด โดยระบบจะตรวจสอบว่าในประโยคที่ผู้ใช้พิมพ์เข้ามา มี "คำหลัก" (Keyword) ที่กำหนดไว้หรือไม่ หากพบคำดังกล่าว ระบบจะดึงคำตอบที่เชื่อมโยงไว้ออกมาทันที วิธีนี้มีความรวดเร็วและแม่นยำสูงในกรณีที่คำถามไม่ซับซ้อน แต่มีข้อจำกัดคือหากผู้ใช้ใช้รูปประโยคอื่นที่ไม่มี Keyword ระบบจะไม่สามารถตอบได้
		2.4.2.2 Synonym Expansion: การขยายความหมายด้วยคำพ้อง เพื่อแก้ปัญหาความแข็งทื่อของ Keyword Matching ระบบจะมีการใช้พจนานุกรมคำพ้องความหมาย (Thesaurus) เข้ามาช่วย โดยกำหนดกลุ่มคำที่มีความหมายเหมือนกันให้ชี้ไปยังเจตนา (Intent) เดียวกัน
		- ตัวอย่าง: การกำหนดให้คำว่า "อาจารย์", "ครู", "ผู้สอน", "Lecturer" ทั้งหมดมีค่าเท่ากับ Intent: INSTRUCTOR_INFO ทำให้ไม่ว่าผู้ใช้จะพิมพ์คำไหนมา ระบบก็สามารถเข้าใจได้ว่าผู้ใช้ ต้องการสอบถามข้อมูลเกี่ยวกับอาจารย์
		2.4.2.3 Fuzzy Matching: การจับคู่คำที่สะกดผิดหรือใกล้เคียง เป็นเทคนิคที่ใช้จัดการกับความผิดพลาดจากการพิมพ์ (Typo) ของผู้ใช้งาน โดยใช้อัลกอริทึมวัดระยะห่างระหว่างคำ (Edit Distance) เช่น Levenshtein Distance ซึ่งคำนวณจำนวนครั้งของการลบ แทรก หรือเปลี่ยนตัวอักษร เพื่อให้คำหนึ่งกลายเป็นอีกคำหนึ่ง
		- การทำงาน: หากผู้ใช้พิมพ์ว่า "สวดี" (พิมพ์ผิด - ตก ส.เสือ) ระบบจะคำนวณความคล้ายคลึงและพบว่าใกล้เคียงกับคำว่า "สวัสดี" มากกว่าเกณฑ์ที่กำหนด (Threshold) จึงอนุมานว่าผู้ใช้ต้องการทักทาย
		2.4.2.4 Regular Expression (Regex): การจับรูปแบบแพทเทิร์นข้อความเฉพาะ Regular Expression คือชุดรหัสรูปแบบอักขระที่ใช้กำหนดแพทเทิร์นการค้นหาข้อความที่มีโครงสร้างแน่นอน (Structured Data) ไม่ใช่การจับคู่คำต่อคำ แต่เป็นการจับคู่ตาม "รูปแบบ"
		- การประยุกต์ใช้: ใช้ในการดึงข้อมูลสำคัญ (Entity Extraction) ออกจากประโยคสนทนา เช่น
			- รหัสนักศึกษา: รูปแบบตัวเลข 10 หลักขึ้นไป
			- เบอร์โทรศัพท์: รูปแบบ 0xx-xxx-xxxx
			- อีเมล: รูปแบบ text + @ + domain.com
			- ประโยชน์: วิธีนี้ช่วยให้บอทสามารถดึงข้อมูลที่ถูกต้องไปประมวลผลต่อได้ทันทีโดยไม่ต้องพึ่งพา AI ที่ซับซ้อน

2.5 ระบบจัดการฐานข้อมูล (Database Management System)
	ระบบจัดการฐานข้อมูล (DBMS) ทำหน้าที่เป็นซอฟต์แวร์ตรงกลางที่ช่วยในการจัดเก็บ ค้นหา และจัดการข้อมูลสำหรับแชทบอท เพื่อให้สามารถดึงข้อมูลมาตอบโต้กับผู้ใช้งานได้อย่างถูกต้องและรวดเร็ว โดยมีรายละเอียดการออกแบบดังนี้
	2.5.1 Relational Database: การใช้ฐานข้อมูลเชิงสัมพันธ์ (MySQL) ฐานข้อมูลเชิงสัมพันธ์ (Relational Database Management System - RDBMS) คือรูปแบบการจัดเก็บข้อมูลในลักษณะของ "ตาราง" (Table) ที่มีความสัมพันธ์เชื่อมโยงกันผ่านคีย์ (Key)
		2.5.1.1 เหตุผลที่เลือกใช้ MySQL: ในการพัฒนาระบบนี้ เลือกใช้ MySQL เนื่องจากเป็นระบบจัดการฐานข้อมูลแบบ Open Source ที่มีความเสถียรสูง รองรับคำสั่ง SQL (Structured Query Language) ที่เป็นมาตรฐานสากล และมีประสิทธิภาพในการประมวลผลข้อมูลจำนวนมาก (Scalability) ซึ่งเหมาะสมกับการจัดเก็บข้อมูลของแชทบอทที่มีการเรียกใช้ข้อมูลตลอดเวลา (High Availability)
		2.5.1.2 หลักการทำงาน: ข้อมูลจะถูกแยกเก็บเป็นตารางย่อยๆ ตามประเภทของข้อมูล และเชื่อมโยงกันด้วยความสัมพันธ์แบบต่างๆ เช่น One-to-One, One-to-Many เพื่อลดความซ้ำซ้อนและรักษาความถูกต้องของข้อมูล (Data Integrity)
	2.5.2 Database Design การออกแบบฐานข้อมูล (Database Design) เป็นขั้นตอนสำคัญในการวางโครงสร้างการจัดเก็บข้อมูลเพื่อให้ระบบทำงานได้อย่างมีประสิทธิภาพสูงสุด
		2.5.2.1 โครงสร้างตารางที่ใช้ (Tables) การออกแบบ Schema ของฐานข้อมูลประกอบด้วยตารางหลัก 4 ตาราง ที่จำเป็นต่อการทำงานของแชทบอท ดังนี้
		1. Table: staff (ข้อมูลบุคลากร): เก็บข้อมูลอาจารย์และบุคลากรของคณะวิศวกรรมศาสตร์
		- Columns: id (PK), name_th, name_en, position_th, position_en, department, email, phone, expertise, photo_url, is_active, created_at, updated_at
		2. Table: faq (คำถาม-คำตอบ): ตารางหลักสำหรับเก็บคำถามที่พบบ่อยและคำตอบ (Knowledge Base)
		- Columns: id (PK), question, answer, keywords, category, department, is_active
		3. Table: news (ข่าวสาร): เก็บข่าวสารและกิจกรรมของคณะ มีการอัปเดตอัตโนมัติผ่าน Web Scraping
		- Columns: id (PK), title, summary, category, link_url, published_date, is_active, created_at
		4. Table: chat_logs (ประวัติการสนทนา): บันทึกการสนทนาเพื่อนำไปวิเคราะห์และปรับปรุงระบบ
		- Columns: id (PK), session_id, user_message, bot_response, sources, confidence, response_time_ms, user_ip, user_agent, created_at
		2.5.2.2 Normalization: การจัดระเบียบข้อมูลเพื่อลดความซ้ำซ้อน Normalization คือกระบวนการออกแบบตารางให้เป็นไปตามกฎมาตรฐาน (Normal Forms) เพื่อลดความซ้ำซ้อนของข้อมูล (Data Redundancy) และป้องกันความผิดปกติในการจัดการข้อมูล (Anomalies)
		- การออกแบบในระบบนี้: ระบบใช้หลักการ Normalization ถึงระดับ 3NF (Third Normal Form) โดยแต่ละตารางมี Primary Key ที่ไม่ซ้ำกัน และคอลัมน์ทั้งหมดขึ้นอยู่กับ Primary Key โดยตรง อย่างไรก็ตาม สำหรับข้อมูลสาขาวิชา (department) ระบบเลือกไม่แยกเป็นตารางแยก แต่เก็บเป็น VARCHAR ในตาราง staff และ faq โดยตรง เนื่องจากข้อมูลสาขามีจำนวนจำกัด (10 สาขา) และไม่มีการเปลี่ยนแปลงบ่อย ซึ่งเป็น Trade-off ระหว่างความเรียบง่ายในการ Query กับการลดความซ้ำซ้อน
		2.5.2.3 Indexing: การทำดัชนีเพื่อเพิ่มประสิทธิภาพการค้นหา Indexing คือเทคนิคการสร้างโครงสร้างข้อมูลพิเศษ (เช่น B-Tree) เพื่อเพิ่มความเร็วในการค้นหาข้อมูล
		- ความสำคัญต่อแชทบอท: แชทบอทต้องตอบสนองแบบ Real-time ดังนั้นการค้นหาข้อมูลโดยไม่มี Index (Full Table Scan) จะทำให้ระบบช้ามาก
		- ประเภท Index ที่ใช้:
		  1. B-Tree Index: ใช้กับคอลัมน์ที่ค้นหาบ่อย เช่น department, is_active, session_id ช่วยให้การค้นหาเร็วขึ้นจาก O(n) เป็น O(log n)
		  2. FULLTEXT Index: ใช้กับตาราง faq สำหรับคอลัมน์ question, keywords, answer เพื่อรองรับการค้นหาข้อความแบบ Natural Language ด้วยคำสั่ง MATCH() AGAINST()
		2.5.2.4 Transaction & ACID: คุณสมบัติการรับประกันความถูกต้องของข้อมูล ACID คือคุณสมบัติ 4 ประการที่รับประกันความถูกต้องและความสมบูรณ์ของข้อมูลเมื่อมีการทำธุรกรรม (Transaction)
		- Atomicity (ความเป็นหน่วยเดียว): การทำงานต้องสำเร็จทั้งหมดหรือไม่ทำเลย (All or Nothing) เช่น เมื่อบันทึก chat log พร้อมอัปเดตสถิติ ต้องสำเร็จพร้อมกัน หากส่วนใดส่วนหนึ่งล้มเหลวระบบจะยกเลิก (Rollback) ทั้งหมด
		- Consistency (ความถูกต้อง): ข้อมูลหลังการทำธุรกรรมต้องถูกต้องตามกฎที่กำหนด เช่น ค่า confidence ต้องอยู่ระหว่าง 0.00-1.00 หรือ is_active ต้องเป็น 0 หรือ 1 เท่านั้น
		- Isolation (ความแยกตัว): เมื่อมีผู้ใช้หลายคนเข้าใช้งานพร้อมกัน การทำธุรกรรมของแต่ละคนต้องไม่กระทบกัน ระบบใช้ระดับ Isolation แบบ READ COMMITTED เพื่อป้องกันการอ่านข้อมูลที่ยังไม่ได้ยืนยัน
		- Durability (ความคงทน): เมื่อข้อมูลถูกบันทึกเสร็จสิ้นแล้ว จะถูกเก็บอย่างถาวรแม้ระบบจะไฟดับหรือเกิดข้อผิดพลาด MySQL มีระบบ Transaction Log และ Crash Recovery อัตโนมัติเพื่อรับประกันคุณสมบัตินี้




2.6 สถาปัตยกรรมเว็บแอปพลิเคชัน (Web Application Architecture)
	สถาปัตยกรรมเว็บแอปพลิเคชัน คือ พิมพ์เขียวหรือโครงสร้างที่กำหนดรูปแบบการปฏิสัมพันธ์ระหว่างแอปพลิเคชัน (Application), มิดเดิลแวร์ (Middleware) และฐานข้อมูล (Database) เพื่อให้ระบบสามารถทำงานร่วมกันได้อย่างมีประสิทธิภาพ รองรับการขยายตัว และง่ายต่อการบำรุงรักษา
	2.6.1 3-Tier Architecture สถาปัตยกรรมแบบ 3 ชั้น (Three-Tier Architecture) เป็นรูปแบบโครงสร้างพื้นฐานที่นิยมที่สุดในการพัฒนาเว็บแอปพลิเคชัน โดยแบ่งระบบออกเป็น 3 ส่วนอิสระที่ทำงานประสานกัน ได้แก่
		2.6.1.1 Presentation Tier (ส่วนแสดงผล)
		- ทำหน้าที่เป็นส่วนติดต่อกับผู้ใช้งาน (User Interface - UI) ผ่านเว็บเบราว์เซอร์หรือแอปพลิเคชัน
		- รับผิดชอบการรับข้อมูลนำเข้า (Input) จากผู้ใช้ และแสดงผลลัพธ์ (Output)
		- เทคโนโลยีที่ใช้มักเป็น HTML, CSS, และ JavaScript (หรือ Framework เช่น React, Vue.js)
		2.6.1.2 Application Tier (ส่วนประมวลผล)
		- เปรียบเสมือนสมองของระบบ หรือที่เรียกว่า "Logic Tier" ทำหน้าที่ประมวลผลตรรกะทางธุรกิจ (Business Logic)
		- รับคำขอ (Request) จากส่วนแสดงผล มาวิเคราะห์ คำนวณ และตัดสินใจ ก่อนจะส่งคำสั่งไปยังฐานข้อมูล
		- เป็นที่อยู่ของโค้ดโปรแกรมหลัก (Source Code) เช่น ภาษา Python, PHP, Node.js หรือ Java
		2.6.1.3 Data Tier (ส่วนข้อมูล)
		- ทำหน้าที่จัดเก็บและบริหารจัดการข้อมูล (Database Management)
		- รับคำสั่งจาก Application Tier เพื่อทำการเพิ่ม ลบ แก้ไข หรือค้นหาข้อมูล (CRUD Operations) และส่งข้อมูลกลับไป
		- ประกอบด้วยระบบฐานข้อมูล เช่น MySQL, PostgreSQL หรือ MongoDB
	2.6.2 MVC Pattern (Model-View-Controller) MVC เป็นรูปแบบสถาปัตยกรรมซอฟต์แวร์ (Software Architectural Pattern) ที่ใช้ในการจัดระเบียบโค้ดภายใน Application Tier เพื่อแยกหน้าที่การทำงานให้ชัดเจน ลดความซับซ้อน และช่วยให้นักพัฒนาหลายคนทำงานร่วมกันได้ง่ายขึ้น ประกอบด้วย 3 ส่วนคือ
		2.6.2.1 Model (ส่วนข้อมูลและตรรกะ)
		- รับผิดชอบจัดการข้อมูลและกฎทางธุรกิจ (Business Logic) เชื่อมต่อกับฐานข้อมูล โดยตรง
		- เมื่อข้อมูลมีการเปลี่ยนแปลง Model จะแจ้งเตือนไปยัง View เพื่ออัปเดตการแสดงผล
		2.6.2.2 View (ส่วนแสดงผล)
		- รับผิดชอบการแสดงผลข้อมูลที่ได้รับจาก Model ให้ผู้ใช้งานเห็น (User Interface)
		- ไม่มีหน้าที่ในการคำนวณหรือประมวลผลตรรกะที่ซับซ้อน
		2.6.2.3 Controller (ส่วนควบคุม)
		- ทำหน้าที่เป็นตัวกลาง (Intermediary) ระหว่าง Model และ View
		- รับ Input จากผู้ใช้ (ผ่าน View) แล้วประมวลผลเพื่อสั่งให้ Model อัปเดตข้อมูล หรือสั่งให้ View เปลี่ยนหน้าจอการแสดงผล
 
รูปที่ 2.6.2.3 Model-View-Controller
	2.6.3 Client-Server Model Client-Server Model คือรูปแบบสถาปัตยกรรมเครือข่ายที่อธิบายกระบวนการสื่อสารและแบ่งหน้าที่ระหว่างคอมพิวเตอร์ 2 ฝั่ง
		2.6.3.1 Client (ฝั่งผู้ใช้)
		- คือเครื่องคอมพิวเตอร์หรืออุปกรณ์ของผู้ใช้งาน (เช่น สมาร์ตโฟนที่เปิดหน้าแชทบอท)
		- ทำหน้าที่เป็น "ผู้ร้องขอ" (Requester) โดยส่งคำขอข้อมูล (Request) ผ่านเครือข่ายอินเทอร์เน็ตไปยังเครื่องแม่ข่าย
		2.6.3.2 Server (ฝั่งเซิร์ฟเวอร์)
		- คือเครื่องคอมพิวเตอร์ประสิทธิภาพสูงที่เปิดใช้งานตลอดเวลา
		- ทำหน้าที่เป็น "ผู้ให้บริการ" (Provider) คอยรับคำขอ (Listening) ประมวลผลตามคำสั่ง และส่งข้อมูลตอบกลับ (Response) ไปยัง Client
		2.6.3.3 กระบวนการทำงาน (Request-Response Cycle)
		- การสื่อสารระหว่าง Client และ Server มักทำผ่านโปรโตคอล HTTP/HTTPS โดย Client ส่ง HTTP Request และ Server ตอบกลับด้วย HTTP Response (พร้อม Status Code เช่น 200 OK, 404 Not Found)
2.7 การเชื่อมต่อผ่าน API (RESTful Services)
	การเชื่อมต่อระหว่างส่วนหน้าบ้าน (Frontend) และหลังบ้าน (Backend) ในระบบแชทบอทปัจจุบัน นิยมใช้รูปแบบ API (Application Programming Interface) เพื่อเป็นสะพานเชื่อมโยงข้อมูล โดยสถาปัตยกรรมที่เป็นมาตรฐานหลักคือ RESTful Services ซึ่งมีความยืดหยุ่นสูงและเป็นสากล
	2.7.1 REST Principles: หลักการออกแบบ API แบบ Stateless REST (Representational State Transfer) เป็นรูปแบบสถาปัตยกรรมซอฟต์แวร์สำหรับการส่งผ่านข้อมูลบนเครือข่ายอินเทอร์เน็ต โดยมีหัวใจสำคัญคือหลักการ Statelessness (ความไร้สถานะ)
		2.7.1.1 ความหมายของ Stateless: ในการสื่อสารแต่ละครั้ง (Request) จาก Client ไปยัง Server จะต้องบรรจุข้อมูลที่จำเป็นทั้งหมดสำหรับการประมวลผลไปด้วยเสมอ Server จะไม่ทำการบันทึกสถานะการเชื่อมต่อ (Session) ของผู้ใช้ไว้ที่ฝั่ง Server เอง
		2.7.1.2 ประโยชน์: ทำให้ Server ไม่ต้องแบกรับภาระหน่วยความจำในการจดจำผู้ใช้งานทุกคน ช่วยให้ระบบสามารถรองรับผู้ใช้งานจำนวนมากได้ (Scalability) และง่ายต่อการขยายระบบ
	2.7.2 HTTP Methods: การใช้คำสั่ง GET, POST, PUT, DELETE ในการสั่งการให้ API ทำงาน RESTful API จะใช้ "คำกริยา" (Verbs) ตามมาตรฐาน HTTP Protocol เพื่อระบุการกระทำที่ต้องการ (Action) ต่อทรัพยากรข้อมูล ดังนี้
		2.7.2.1 GET (ดึงข้อมูล): ใช้สำหรับร้องขอข้อมูลจาก Server โดยไม่มีการเปลี่ยนแปลงแก้ไขข้อมูลใดๆ เช่น การดึงประวัติการสนทนา หรือการดึงข้อมูลสินค้า
		2.7.2.2 POST (ส่งข้อมูล/สร้างใหม่): ใช้สำหรับส่งข้อมูลใหม่ไปบันทึกที่ Server เช่น การส่งข้อความแชทที่ผู้ใช้เพิ่งพิมพ์ (Input Message) ไปประมวลผล
		2.7.2.3 PUT (แก้ไข/แทนที่): ใช้สำหรับการอัปเดตข้อมูลที่มีอยู่แล้วให้เป็นค่าใหม่ เช่น การแก้ไขข้อมูลส่วนตัวสมาชิก หรือการเปลี่ยนสถานะงาน
		2.7.2.4 DELETE (ลบ): ใช้สำหรับสั่งลบข้อมูลออกจากฐานข้อมูล เช่น การลบบัญชีผู้ใช้ หรือลบรายการสินค้า
	2.7.3 JSON Format: รูปแบบข้อมูลมาตรฐานที่ใช้รับส่ง JSON (JavaScript Object Notation) คือรูปแบบมาตรฐานในการจัดเก็บและแลกเปลี่ยนข้อมูลคอมพิวเตอร์ ซึ่งเข้ามาแทนที่ XML เนื่องจากมีโครงสร้างที่กะทัดรัดและประมวลผลได้เร็วกว่า
		2.7.3.1 โครงสร้าง: จัดเก็บข้อมูลในรูปแบบคู่ของ Key: Value (Key-Value Pair) ภายใต้วงเล็บปีกกา { } ซึ่งมนุษย์สามารถอ่านเข้าใจได้ง่าย (Human-readable)
	2.7.4 Security: การรักษาความปลอดภัย เนื่องจาก API เป็นช่องทางเข้าออกของข้อมูลสำคัญ ระบบจึงต้องมีมาตรการรักษาความปลอดภัยที่เข้มงวด
		2.7.4.1 HTTPS (Hypertext Transfer Protocol Secure): การเข้ารหัสข้อมูลในระหว่างการส่งผ่านเครือข่าย (Data in Transit) ด้วยโปรโตคอล SSL/TLS เพื่อป้องกันการดักจับหรือแอบอ่านข้อมูล (Eavesdropping) โดยผู้ไม่หวังดี
		2.7.4.2 API Key / Authentication: การระบุตัวตนผู้ใช้งาน API โดยผู้ใช้หรือแอปพลิเคชันต้องแนบรหัสผ่านพิเศษ (API Key หรือ Token) มากับทุก Request เพื่อให้ Server ตรวจสอบสิทธิ์ว่าได้รับอนุญาตให้เข้าถึงข้อมูลหรือไม่ และยังช่วยป้องกันการโจมตีแบบ Spam Request ได้อีกด้วย

2.8 การออกแบบส่วนติดต่อผู้ใช้ (UI/UX Design)
	การออกแบบส่วนติดต่อผู้ใช้ (User Interface - UI) และประสบการณ์ผู้ใช้ (User Experience - UX) เป็นปัจจัยสำคัญที่จะกำหนดความสำเร็จของระบบแชทบอท การออกแบบที่ดีต้องคำนึงถึงความสะดวกในการใช้งาน การเข้าถึงข้อมูลที่ง่าย และความรู้สึกพึงพอใจของผู้ใช้งาน โดยมีหลักการสำคัญดังนี้
	2.8.1 Usability Principles: ความสม่ำเสมอ (Consistency) และความเรียบง่าย (Simplicity) หลักการ "Usability" หรือความสามารถในการใช้งาน มุ่งเน้นการลดภาระทางความคิดของผู้ใช้ (Cognitive Load) เพื่อให้ผู้ใช้สามารถบรรลุเป้าหมายได้อย่างรวดเร็ว

		2.8.1.1 ความสม่ำเสมอ (Consistency): การออกแบบต้องเป็นไปในทิศทางเดียวกันทั้งระบบ
		- Visual Consistency: การใช้โทนสี รูปแบบตัวอักษร และไอคอน ให้เหมือนกันทุกหน้า เพื่อสร้างความจดจำ (Brand Identity)
		- Functional Consistency: ตำแหน่งของปุ่มสั่งการหรือเมนูต้องวางอยู่ในตำแหน่งเดิม ไม่ย้ายไปมา เพื่อให้ผู้ใช้เกิดความคุ้นเคยและเรียนรู้การใช้งานได้เร็ว (Learnability)
		2.8.1.2 ความเรียบง่าย (Simplicity): การตัดสิ่งที่ไม่จำเป็นออกตามหลักการ "Less is More"
		- ลดจำนวนขั้นตอนการคลิก (Clicks) ให้เหลือเท่าที่จำเป็น
		- ใช้พื้นที่ว่าง (White Space) เพื่อให้อ่านง่ายและสบายตา
		- หลีกเลี่ยงการแสดงข้อมูลที่หนาแน่นเกินไปในหน้าจอสนทนา เพื่อให้ผู้ใช้โฟกัสกับเนื้อหาหลักได้ทันที
	2.8.2 Responsive Design: การแสดงผลที่รองรับทุกหน้าจอ (Mobile-first) โดยเฉพาะบนมือถือ ในยุคปัจจุบัน ผู้ใช้งานส่วนใหญ่นิยมเข้าถึงอินเทอร์เน็ตผ่านสมาร์ตโฟน การออกแบบจึงต้องยึดหลัก Mobile-First Strategy คือการให้ความสำคัญกับการออกแบบบนหน้าจอมือถือเป็นลำดับแรก ก่อนจะขยายไปยังหน้าจอขนาดใหญ่
		2.8.2.1 Liquid Layout & Flexible Grids: การใช้โครงสร้างหน้าเว็บที่ยืดหยุ่น สามารถปรับขนาดและความกว้างขององค์ประกอบต่างๆ (เช่น กล่องข้อความ รูปภาพ ปุ่มกด) ให้พอดีกับความกว้างของหน้าจออุปกรณ์ (Viewport) โดยอัตโนมัติ
		2.8.2.2 Touch-Friendly Interface: การออกแบบจุดสัมผัส (Touch Targets) เช่น ปุ่มเมนู หรือตัวเลือก Quick Reply ให้มีขนาดใหญ่พอที่นิ้วมือจะสัมผัสได้แม่นยำ (โดยทั่วไปควรมีขนาดไม่ต่ำกว่า 44x44 pixels) และมีการเว้นระยะห่างเพื่อป้องกันการกดผิด
		2.8.2.3 Readable Content: ขนาดตัวอักษรต้องอ่านง่ายโดยไม่ต้องซูมหน้าจอ และจัดลำดับความสำคัญของเนื้อหาให้เหมาะสมกับพื้นที่จำกัด
	2.8.3 Conversational Design: หลักการออกแบบบทสนทนาให้ดูเป็นธรรมชาติ ไม่เหมือนหุ่นยนต์จนเกินไป Conversational Design คือศาสตร์ของการออกแบบ "บทพูด" ให้กับระบบ เพื่อให้ผู้ใช้งานรู้สึกเหมือนกำลังสนทนากับมนุษย์ (Human-like Interaction) มากกว่าการป้อนคำสั่งคอมพิวเตอร์
		2.8.3.1 Persona Development: การกำหนดบุคลิกภาพของแชทบอทให้ชัดเจน เช่น การใช้สรรพนาม (ผม/ดิฉัน/น้อง) น้ำเสียง (ทางการ/เป็นกันเอง) เพื่อสร้างอารมณ์ร่วมและความน่าเชื่อถือ
		2.8.3.2 Cooperative Principle: การออกแบบบทสนทนาตามหลักความร่วมมือ โดยบอทต้องให้ข้อมูลที่ "กระชับ ตรงประเด็น และชัดเจน" ไม่ตอบยาวเหยียดจนผู้ใช้จับใจความไม่ได้
		2.8.3.3 Turn-taking & Feedback: ระบบต้องมีการโต้ตอบที่แสดงสถานะชัดเจน เช่น การแสดงสัญลักษณ์ "กำลังพิมพ์..." (Typing Indicator) เพื่อให้ผู้ใช้รู้ว่าระบบกำลังประมวลผลอยู่ และไม่รู้สึกว่าถูกทิ้งให้รอเก้อ
		2.8.3.4 Error Handling: เมื่อบอทไม่เข้าใจคำสั่ง ต้องมีการออกแบบประโยคตอบรับที่สุภาพและแนะนำทางเลือก (Fallback Message) เช่น "ขอโทษครับ ผมไม่แน่ใจว่าเข้าใจถูกไหม คุณหมายถึง...ใช่หรือไม่?" แทนที่จะตอบแค่ว่า "Error" หรือไม่ตอบเลย

2.9 เครื่องมือและซอฟต์แวร์ที่ใช้ในการพัฒนา
	ในการพัฒนาระบบ Smart Information Chatbot System of Engineering คณะผู้จัดทำได้คัดเลือกเครื่องมือและซอฟต์แวร์ที่เหมาะสมกับลักษณะงานในแต่ละขั้นตอน เพื่อให้กระบวนการพัฒนาเป็นไปอย่างมีประสิทธิภาพ ครบถ้วน และเป็นมาตรฐาน โดยมีรายละเอียดดังนี้

	2.9.1 ระบบจัดการฐานข้อมูล (Database Management System)
		MySQL 8.0+ / MariaDB 10.5+: เป็นระบบจัดการฐานข้อมูลเชิงสัมพันธ์ (RDBMS) แบบ Open Source ที่มีความเสถียรสูง รองรับการทำงานพร้อมกันของผู้ใช้งานจำนวนมาก (Concurrency) และมีประสิทธิภาพในการประมวลผล Query ที่ซับซ้อน เหมาะสำหรับการจัดเก็บข้อมูลบุคลากร FAQ ข่าวสาร และประวัติการสนทนา ระบบรองรับคุณสมบัติ FULLTEXT Index สำหรับการค้นหาข้อความภาษาไทย และมีกลไกการจัดการ Transaction ตามมาตรฐาน ACID เพื่อรับประกันความถูกต้องของข้อมูล

	2.9.2 ภาษาโปรแกรม (Programming Languages)
		2.9.2.1 PHP 8.0+: ใช้เป็นภาษาหลักในการพัฒนาฝั่ง Backend สำหรับการจัดการคำขอจากผู้ใช้ (Request Handling) การเชื่อมต่อฐานข้อมูล การประมวลผลตรรกะทางธุรกิจ และการสร้าง RESTful API เลือกใช้ PHP เนื่องจากมีความเข้ากันได้ดีกับ Apache Server และมีฟังก์ชันสำเร็จรูปสำหรับการทำงานกับ MySQL อีกทั้งยังมี Community ขนาดใหญ่ที่ให้การสนับสนุน
		2.9.2.2 Python 3.8+: ใช้ในการพัฒนาส่วนปัญญาประดิษฐ์ (AI Engine) เนื่องจากมี Library ที่หลากหลายสำหรับ Machine Learning และ Natural Language Processing โดยเฉพาะอย่างยิ่ง
			- pythainlp 4.0.2: ใช้สำหรับการประมวลผลภาษาไทย (Tokenization, Stop Words Removal)
			- scikit-learn 1.3.0: ใช้สำหรับการสร้างโมเดล Machine Learning (TF-IDF, Logistic Regression, Cosine Similarity)
			- pandas 2.0.3: ใช้ในการจัดการและวิเคราะห์ข้อมูล (Data Manipulation)
			- Flask 2.3.2: ใช้สร้าง REST API สำหรับเชื่อมต่อระหว่าง AI Engine กับ Frontend
			- numpy 1.24.3: ใช้สำหรับการคำนวณเชิงตัวเลข (Numerical Computing)
		2.9.2.3 JavaScript (ES6+): ใช้ในการพัฒนาฝั่ง Frontend สำหรับการสร้างปฏิสัมพันธ์กับผู้ใช้งาน (User Interaction) การส่ง AJAX Request ไปยัง Backend และการแสดงผลแบบ Dynamic โดยไม่ต้อง Reload หน้า
		2.9.2.4 HTML5 & CSS3: ใช้ในการสร้างโครงสร้างหน้าเว็บ (Markup) และการออกแบบรูปลักษณ์ส่วนติดต่อผู้ใช้ (Styling) รองรับการออกแบบแบบ Responsive เพื่อให้แสดงผลได้ดีทั้งบนคอมพิวเตอร์และมือถือ

	2.9.3 เว็บเซิร์ฟเวอร์ (Web Server)
		XAMPP / WAMP: เป็น Software Package ที่รวม Apache HTTP Server, MySQL Database และ PHP Interpreter เข้าด้วยกัน ทำให้สามารถติดตั้งและจัดการ Local Development Environment ได้อย่างสะดวก โดย Apache ทำหน้าที่เป็น Web Server รับ HTTP Request จากผู้ใช้งาน และส่งผลลัพธ์กลับผ่านโปรโตคอล HTTP/HTTPS

	2.9.4 ระบบควบคุมเวอร์ชัน (Version Control System)
		Git & GitHub: Git เป็นระบบควบคุมเวอร์ชันแบบกระจาย (Distributed Version Control) ที่ช่วยให้สมาชิกในทีมสามารถทำงานร่วมกันได้อย่างมีประสิทธิภาพ โดยสามารถติดตามการเปลี่ยนแปลงของโค้ด (Change Tracking) ย้อนกลับไปยังเวอร์ชันก่อนหน้า (Rollback) และรวมงานจากหลายคนเข้าด้วยกัน (Merge) GitHub ใช้เป็นแพลตฟอร์มออนไลน์สำหรับเก็บ Repository และอำนวยความสะดวกในการทำ Code Review และ Collaboration

	2.9.5 โปรแกรมพัฒนาและแก้ไขโค้ด (IDE & Code Editors)
		2.9.5.1 Visual Studio Code: เป็น Code Editor ที่ใช้ในการเขียนและแก้ไขโค้ดทุกภาษา รองรับ Extensions มากมาย เช่น
			- PHP Intelephense: สำหรับ Auto-completion และตรวจสอบไวยากรณ์ PHP
			- Python Extension: สำหรับ Debugging และรัน Python Script
			- Prettier: สำหรับจัดรูปแบบโค้ดให้สวยงามและเป็นมาตรฐาน
			- Live Server: สำหรับทดสอบหน้าเว็บแบบ Real-time
		2.9.5.2 phpMyAdmin: เป็น Web-based Tool สำหรับจัดการฐานข้อมูล MySQL ผ่านหน้าเว็บ ช่วยให้สามารถสร้างตาราง แก้ไขข้อมูล รัน SQL Query และ Import/Export ข้อมูลได้อย่างสะดวก โดยไม่ต้องใช้คำสั่ง Command Line

	2.9.6 เครื่องมือทดสอบ API (API Testing Tools)
		2.9.6.1 Postman: ใช้สำหรับทดสอบการทำงานของ RESTful API โดยสามารถส่ง HTTP Request ประเภทต่างๆ (GET, POST, PUT, DELETE) พร้อมกำหนด Headers, Parameters และ Body ได้อย่างยืดหยุ่น ช่วยให้นักพัฒนาสามารถตรวจสอบความถูกต้องของ Response และ Debug ปัญหาได้รวดเร็ว
		2.9.6.2 Thunder Client (VS Code Extension): เป็นทางเลือกแบบ Lightweight สำหรับการทดสอบ API ภายใน VS Code โดยตรง โดยไม่ต้องเปิดโปรแกรมแยก

	2.9.7 เครื่องมือสร้างไดอะแกรมและเอกสาร (Diagram & Documentation Tools)
		2.9.7.1 Draw.io (diagrams.net): เป็น Web-based Tool สำหรับวาดไดอะแกรมต่างๆ เช่น ER Diagram, Flowchart, System Architecture Diagram, Use Case Diagram ใช้งานฟรีและสามารถส่งออกเป็นไฟล์ภาพ (PNG, JPG, SVG) หรือ PDF ได้
		2.9.7.2 Microsoft Excel / Google Sheets: ใช้สำหรับการสร้างกราฟและตารางสรุปข้อมูล เช่น ตารางเปรียบเทียบเครื่องมือ กราฟแสดงผลการทดสอบ และการวิเคราะห์ข้อมูลเชิงสถิติ
		2.9.7.3 Microsoft Word: ใช้สำหรับจัดทำเอกสารรายงาน รวบรวมไดอะแกรม ตาราง และผลการทดสอบเข้าด้วยกัน

	2.9.8 เครื่องมือสำหรับ Machine Learning (ML Development Tools)
		2.9.8.1 Jupyter Notebook: เป็นสภาพแวดล้อมแบบ Interactive สำหรับการเขียนโค้ด Python และแสดงผลทันที เหมาะสำหรับการทดลอง Train โมเดล วิเคราะห์ข้อมูล และสร้าง Visualization ในขั้นตอนการพัฒนา AI Engine
		2.9.8.2 Google Colab (ทางเลือก): ใช้สำหรับการ Train โมเดลที่ต้องการ GPU เนื่องจากให้บริการ Free GPU สำหรับการประมวลผล

	2.9.9 เครื่องมือจับภาพหน้าจอ (Screenshot Tools)
		2.9.9.1 Snipping Tool / Snip & Sketch (Windows): ใช้สำหรับจับภาพหน้าจอระบบเพื่อนำมาประกอบเอกสารรายงาน เช่น ภาพหน้าจอส่วนติดต่อผู้ใช้ ภาพผลการทดสอบ
		2.9.9.2 Lightshot / ShareX (ทางเลือก): เครื่องมือจับภาพหน้าจอที่มีฟีเจอร์เพิ่มเติม เช่น การเพิ่มคำอธิบาย ลูกศร หรืออัปโหลดภาพไปยัง Cloud

	2.9.10 เว็บเบราว์เซอร์ (Web Browsers)
		2.9.10.1 Google Chrome: ใช้เป็นเบราว์เซอร์หลักในการพัฒนาและทดสอบระบบ มี Developer Tools (F12) ที่ครบครันสำหรับ Debugging JavaScript, ตรวจสอบ Network Request และวิเคราะห์ Performance
		2.9.10.2 Mozilla Firefox / Microsoft Edge: ใช้สำหรับทดสอบ Cross-browser Compatibility เพื่อให้มั่นใจว่าระบบทำงานได้ดีในทุกเบราว์เซอร์

	2.9.11 เครื่องมือเสริมอื่นๆ (Additional Tools)
		2.9.11.1 FileZilla (FTP Client): ใช้สำหรับอัปโหลดไฟล์โปรเจคไปยังเซิร์ฟเวอร์จริง (Production Server) ผ่านโปรโตคอล FTP/SFTP
		2.9.11.2 Notepad++: ใช้เป็น Text Editor สำรองสำหรับการแก้ไขไฟล์ Configuration หรือ Log Files อย่างรวดเร็ว
		2.9.11.3 DBeaver (ทางเลือก): เป็น Database Management Tool ที่รองรับหลาย Database System มีฟีเจอร์ขั้นสูงสำหรับการจัดการฐานข้อมูลขนาดใหญ่

	2.9.12 สรุปการใช้งานเครื่องมือแยกตามขั้นตอน
		ตารางต่อไปนี้แสดงการจับคู่เครื่องมือกับขั้นตอนการพัฒนาในแต่ละระยะ:

		| ขั้นตอนการพัฒนา | เครื่องมือที่ใช้ |
		|---|---|
		| วิเคราะห์และออกแบบระบบ | Draw.io, Microsoft Word, Excel |
		| สร้างฐานข้อมูล | MySQL, phpMyAdmin |
		| พัฒนา Backend (PHP) | VS Code, PHP Intelephense, Apache (XAMPP) |
		| พัฒนา AI Engine (Python) | VS Code, Jupyter Notebook, pythainlp, scikit-learn, Flask |
		| พัฒนา Frontend | VS Code, Live Server, Chrome DevTools |
		| ทดสอบ API | Postman, Thunder Client |
		| ควบคุมเวอร์ชัน | Git, GitHub |
		| จัดทำเอกสาร | Word, Excel, Draw.io, Snipping Tool |
		| Deploy & Maintenance | FileZilla, Chrome, phpMyAdmin |

		การเลือกใช้เครื่องมือที่เหมาะสมในแต่ละขั้นตอนช่วยให้กระบวนการพัฒนาระบบเป็นไปอย่างราบรื่น มีมาตรฐาน และสามารถทำงานร่วมกันภายในทีมได้อย่างมีประสิทธิภาพสูงสุด
